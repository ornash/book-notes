#+TITLE: Notes on Structure and Interpretation of Computer Programs
#+STARTUP: indent
[[./sicp.html][HTML Export]]


* Chapter 1 : Building Abstractions with Procedures
** Computational Process
Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract
things called data. The evolution of a process is directed by a pattern of rules called a program. People create
programs to direct processes.

** Elements of Programming
Every powerful language has three mechanisms for expressing processes:
1. *primitive expressions*, which represent the simplest entities the language is concerned with,
2. *means of combination*, by which compound elements are built from simple ones, and
3. *means of abstraction*, by which compound elements can be named and manipulated as units.

** Procedure/Program Application/Evaluation
A substition model is used for procedure application. There are two evalution methods for procedure application:
1. *Applicative-order evaluation*: evaluate the arguments and then apply. An argument is evaluated only once but that
   evaluation is going to be wasteful if the argument isn't used.
2. *Normal-order evaluation*: fully expand and then reduce/evaluate i.e. obtain expression involving only primitives and
   then evaluate. An argument isn't evaluated until it is used but it might be evaluated more than once after full expansion.

** Procedures and the Processes They Generate
We now know the elements of programming, but that is not enough to say that we know how to program. In order to become
expert programmer, we must learn to visualize the processes generated by various types of procedures. We must also learn
to calculate the rates at which the procedure consumes the computational resources of time and space.

*** Recursive Procedures
Evaluate and visualize the processes generated by following *recursive procedures* in terms of time and space.
#+BEGIN_SRC scheme
;;Recursive procedure that generates *recursive* process.
(define (factorial n)
  (if (= n 1)
    1
    (* n (factorial (- n 1)))))

;;Recursive procedure that generates *iterative* process.
(define (factorial-iter n)
  (define (iter product counter)
    (if (> counter n)
      product
      (iter (* counter product)
            (+ counter 1))))
  (iter 1 1))  
#+END_SRC

When we consider the "shapes" of the two processes, we see that they evolve quite differently. One grows and shrinks
while other is lean. Carrying out the *recursive* process requires that the interpreter keep track of some *hidden*
information and operations to be performed later on. On the other hand, carrying out the *iterative* process does not
require processing any hidden information, its state can be summarized by fixed number of state variables in the
procedure.

The implementation that generates iterative process is called as *tail recursive* implementation. In tail recursive
implementation the last statement is a call to recursive procedure itself with no work left to be performed in current
procedure call; therefore, compiler can optimize such call by replacing current stack frame instead of creating a new
one.

*** Tree Recursion
Evaluate and visualize the processes generated by following *recursive procedures* in terms of time and space.
#+BEGIN_SRC scheme
;;Recursive procedure that generates *tree recursive* process.
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))
  ))

;;Recursive procedure that generates *iterative* process.
(define (fib-iter n)
  (define (iter a b count)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          ((= count n) a)
          (else (iter (+ a b) a (+ count 1)))))
   (iter 1 0 1))
#+END_SRC

Tree recursion is a powerful tool to operate on hierarchically structured data.

*** Decomposition
Functional procedures encourage reuse because every computation unit is defined as a function which can be used somewhere
else. Decomposition into units also helps transform one implementation into other quickly.

** Formulating Abstractions with Higher Order Procedures
** Miscellaneous
*** Writing Recursive Programs
Think in terms of smallest/simplest units of computation that is already available or you can achieve, then assemble
small units to build larger units. Start with the base case and build up.
Express your computation in as less words as possible, less code leads to less bugs.
Do not think of simplifying your recursive program to generate an iterative process instead of recursive process
immediately. First write a program that generates recusive and then improve it so that it generates iterative process.
*** Advantages of Recursive Programs
- Compare the amount of code written for recursive/functional programs with equivalent code in procedural programming,
*When you think differently, you write less code.* 
- You are able to write full fledged programs by only knowing about few core concepts.

* Chapter 2 : Building Abstractions with Data


* Miscellaneous
